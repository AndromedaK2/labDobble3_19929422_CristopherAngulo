package model.deck;
import common.Helper;
import model.card.Card;

import java.util.*;
import java.util.stream.Collectors;


public class Dobble implements  IDobble {

    //region attributes
    /**
     * @description id is generated by a random function
     * @see Helper
     */
    private int id;
    /**
     * @description represent card list of dobblegame
     */
    private List<Card> dobbleCards = new ArrayList<>();
    /**
     * @description represent dobble elements and symbols
     */
    private List<Object> allElements;
    /**
     * @description represent missing cards
     */
    private List<Card> missingCards = new ArrayList<>();
    /**
     * @description represent order of dobble (projective plane)
     */
    private int order;
    /**
     * @description represent elements per card to create each card
     */
    private int elementsPerCard;
    //endregion

    //region getter and setters

    /**
     * @implNote  get dobble cards
     * @return card list
     */
    public List<Card> getDobbleCards() {
        return dobbleCards;
    }

    /**
     * @implNote  get missing cards
     * @return card list
     */
    public List<Card> getMissingCards(){
        return missingCards;
    }

    /**
     * @implNote  set dobble cards
     * @return card list
     */
    public void setDobbleCards(List<Card> dobbleCards) {
        this.dobbleCards = dobbleCards;
    }
    //endregion

    //region constructor

    /**
     * Main Constructor
     * @description create first card, create n cards, create n^2 cards. Shuffle Cards
     * validate if total cards is equal to max number of cards, if not true we refill dobble cards and missing cards
     * @param elements  symbols or elements of cards
     * @param elementsPerCard quantity elements per card
     * @param maximumTotalCards maximum total cards of deck
     */
    public Dobble(List<Object> elements, int elementsPerCard, int maximumTotalCards) {
        this.id = Helper.generateRandomNumber(1,10000000);
        this.allElements  = elements;
        this.elementsPerCard = elementsPerCard;
        this.order = getOrder(elementsPerCard);
        addCard(createFirstCard(elements,order));
        addCards(createNCards(elements,order));
        addCards(createNSquareCards(elements,order));
        shuffle();
        if(!(getMaxNumberOfCards(order)==maximumTotalCards)){
            List<Card> dobbleCards =  new ArrayList<>();
            int i = 0;

            for (; i < maximumTotalCards ; i++) {
                dobbleCards.add(this.dobbleCards.get(i));
            }

            for (int j = i; j <this.dobbleCards.size();j++){
                this.missingCards.add(this.dobbleCards.get(j));
            }

            this.dobbleCards = dobbleCards;

        }
    }

    //endregion

    //region public methods

    /**
     * @implNote  accord two assumptions we return true if  all cards have different elements inside and
     * between all cards have only one element in common
     * @return true if is dobble or false if is not
     */
    public boolean isDobble() {
        boolean allCardsHaveDifferentElements        = this.allCardsHaveDifferentElements();
        boolean betweenAllCardsHaveDifferentElements = this.betweenAllCardsHaveOneElementInCommon();
        return (allCardsHaveDifferentElements && betweenAllCardsHaveDifferentElements)? true : false;
    }

    /**
     * @implNote this method return missing cards in a string format similar to dobble cards
     * @return representation of missing cards in string
     */
    public String missingCards() {
        String missingCardsString = "\nCartas Faltantes: \n";
        for (int i = 0; i < missingCards.size(); i++) {
            Card card = missingCards.get(i);
            String cardString = card.toString();
            missingCardsString = missingCardsString.concat(cardString);
        }
        return ""+missingCardsString;
    }

    /**
     * @implNote get a card of card list with a specific position
     * @param cards represent list of cards where we search
     * @param position represent position number (index to search)
     * @return card
     */
    public Card getNthCard(List<Card> cards, int position) {
        return cards.get(position);
    }

    /**
     * @implNote get a card of card list with a specific position
     * @param position represent position number (index to search)
     * @return card
     */
    public Card getNthCard(int position) {
        return this.dobbleCards.get(position);
    }

    /**
     * @implNote
     * @param card
     * @return required elements to create dobble
     */
    public int getRequiredElements(Card card) {
        int elementsPerCard = card.getElements().size();
        int order = getOrder(elementsPerCard);
        return (order * order)+ order + 1;
    }

    /**
     * @implNote  get total cards to create dobble cards
     * @param card represent a card
     * @return total cards to create dobble
     */
    public int getTotalCards(Card card) {
        int elementsPerCard = card.getElements().size();
        int order = getOrder(elementsPerCard);
        return (order * order)+ order + 1;
    }

    /**
     * @implNote  get maximum number of cards that we can create accord the order
     * @param order represent order (projective plane)
     * @return maximum number of cards
     */
    public int getMaxNumberOfCards(int order){
        return (order*order)+order+1;
    }

    /**
     * @implNote add cards to dobble cards
     * @param cards represent card list to add
     */
    public void addCards(List<Card> cards){
        for (int i = 0; i < cards.size(); i++) {
            dobbleCards.add(getNthCard(cards,i));
        }
    }

    /**
     * @implNote  add a new card in dobble cards
     * @param card represent a card of dobble cards
     */
    public void addCard(Card card){
        dobbleCards.add(card);
    }

    /**
     * @implNote  remove a card in dobble cards
     * @param card represent a card of dobble cards
     */
    public void removeCard(Card card){
        this.dobbleCards.remove(card);
    }

    /**
     * @implNote  this method is overriding to return a dobble string
     * @return dobble in a string format
     */
    @Override
    public String toString() {
        String dobbleCardsString = "Mazo de cartas: \n";
        for (int i = 0; i < dobbleCards.size(); i++) {
            Card card = dobbleCards.get(i);
            String cardString = card.toString();
            dobbleCardsString = dobbleCardsString.concat(cardString);
        }
        return  dobbleCardsString;
    }

    /**
     * @implNote verify if 2 objects are equals accord properties and others validations
     * @param o any object
     * @return true if objects are equals or false if objects are not equals
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Dobble)) return false;
        Dobble dobble = (Dobble) o;
        return id == dobble.id && order == dobble.order
                && elementsPerCard == dobble.elementsPerCard
                && Objects.equals(dobbleCards, dobble.dobbleCards)
                && Objects.equals(allElements, dobble.allElements)
                && Objects.equals(missingCards, dobble.missingCards);
    }
    //endregion

    //region private methods

    /**
     * @implNote Create first card
     * @param elements represent object list
     * @param order represent order (projective plane)
     * @return The first card of dobble cards
     */
    private Card createFirstCard(List<Object> elements,Integer order) {
        Card card = new Card();
        for (int i=0; i<order+1;i++){
            Object element = elements.get(i);
            card.addElement(element);
        }
        return card;
    }

    /**
     * @implNote  Create N Cards
     * @param elements represent object list
     * @param order represent order (projective plane)
     * @return card list accord to N
     */

    private List<Card> createNCards(List<Object> elements,int order) {
        List<Card> cards = new ArrayList<>();
        for (int j=1; j<=order; j++) {
            Object firstElement  =  elements.get(0);
            Card card = new Card();
            card.addElement(firstElement);

            for (int k=1; k<=order; k++) {
                Object element = elements.get(calculateIndexToGetNCards(order,j,k));
                card.addElement(element);
            }
            cards.add(card);
        }
        return  cards;
    }

    /**
     * @implNote  Create N square cards
     * @param elements represent object list
     * @param order represent order (projective plane)
     * @return card list accord to N square
     */
    private List<Card> createNSquareCards(List<Object> elements,int order) {
        List<Card> cards = new ArrayList<>();
        for (int i= 1; i<=order; i++) {
            for (int j=1; j<=order; j++) {
                Card card = new Card();
                card.addElement(elements.get(i));
                for (int k=1; k<= order; k++) {
                    Object element = elements.get(calculateIndexToGetNSquareCards(i,order,j,k));
                    card.addElement(element);
                }
                cards.add(card);
            }
        }
        return  cards;
    }

    /**
     * @implNote  calculate index to get an element in the creation of N cards
     * @param order represent order (projective plane)
     * @param j first helper
     * @param k second helper
     * @return index to get a element in the creation of N cards.
     */
    private int calculateIndexToGetNCards( int order, int j, int k){
        return (order * j + (k+1))-1;
    }

    /**
     * @implNote  calculate index to get an element in the creation of n square cards
     * @param i first helper
     * @param order represent order (projective plane)
     * @param j second helper
     * @param k third helper
     * @return index to get a element in the creation of N square cards.
     */
    private int calculateIndexToGetNSquareCards(int i, int order, int j, int k){
        return (order+2+order*(k-1)+(((i-1)*(k-1)+j-1) % order))-1;
    }

    /**
     * @implNote get order with  element per card input
     * @param elementPerCard represent a number element per card
     * @return order
     */
    private int getOrder(int elementPerCard){
        return elementPerCard -1;
    }

    /**
     * @implNote shuffle current dobble cards
     */
    private void shuffle() {
        dobbleCards.sort(Comparator.comparingInt(Card::getId));
    }

    /**
     * @implNote  validate if all cards have different elements
     * @return true if all cards have different elements or false if they have not
     */
    private boolean allCardsHaveDifferentElements (){
        return this.dobbleCards.stream().allMatch(card -> card.getElements().stream().distinct().count() == this.elementsPerCard);
    }

    /**
     * @implNote  validate if between all cards have different elements
     * @return true if between all cards have different elements or false if they have not
     */
    private boolean betweenAllCardsHaveOneElementInCommon(){
        int auxiliary = 0;
        for (int i = 0; i < this.dobbleCards.size() ; i++) {
            auxiliary = auxiliary+1;

            for (int j = auxiliary; j < this.dobbleCards.size(); j++) {
                Card firstCard =  this.dobbleCards.get(i);
                Card nextCard  =  this.dobbleCards.get(j);
                if( !(firstCard.getElements().stream().filter(nextCard.getElements()::contains).
                        collect(Collectors.toList()).size() == 1)) {
                    return false;
                }
            }
        }
        return true;
    }

    //endregion

}